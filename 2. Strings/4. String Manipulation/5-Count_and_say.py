"""
Count and Say

The count-and-say sequence is a sequence of digit strings defined by the recursive formula:

countAndSay(1) = "1"
countAndSay(n) is the run-length encoding of countAndSay(n - 1).
Run-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string "3322251" we replace "33" with "23", replace "222" with "32", replace "5" with "15" and replace "1" with "11". Thus the compressed string becomes "23321511".

Given a positive integer n, return the nth element of the count-and-say sequence.

Example 1:

Input: n = 4

Output: "1211"

Explanation:

countAndSay(1) = "1"
countAndSay(2) = RLE of "1" = "11"
countAndSay(3) = RLE of "11" = "21"
countAndSay(4) = RLE of "21" = "1211"

Example 2:

Input: n = 1

Output: "1"

Explanation:

This is the base case.

Constraints:

1 <= n <= 30

Follow up: Could you solve it iteratively?
"""
class Solution(object):
    def countAndSay(self, n):
        """
        Generate the n-th term of the "count-and-say" sequence.
        
        The sequence starts with "1".
        Each subsequent term is generated by "reading" the previous term:
        - Count consecutive identical digits and say the count followed by the digit.
        
        Example:
        1: "1"
        2: "11"          (one 1)
        3: "21"          (two 1s)
        4: "1211"        (one 2, then one 1)
        5: "111221"      (three 1s, then two 2s, then one 1)
        """
        # Step 1: Start with the 1st term of the sequence
        res = '1'
        
        # Step 2: Generate the next (n-1) terms
        # We already have term 1, so loop from 2 to n
        for _ in range(1, n):
            seq = []                    # List to build the next term (using list for efficient appends)
            seq_append = seq.append     # Cache append method for slight performance gain
            
            prev = res[0]               # Current digit we are counting
            cnt = 1                     # Count of consecutive occurrences of prev
            
            # Step 3: Iterate through the rest of the current term
            for ch in res[1:]:
                if ch == prev:
                    # Same digit → increase count
                    cnt += 1
                else:
                    # Different digit → say the count and the previous digit
                    seq_append(str(cnt))   # Append the count
                    seq_append(prev)       # Append the digit
                    prev = ch              # Start counting new digit
                    cnt = 1                # Reset count to 1
            
            # Step 4: After the loop, append the last group (count + digit)
            seq_append(str(cnt))
            seq_append(prev)
            
            # Step 5: Join the list into a string to form the next term
            res = ''.join(seq)
        
        # Step 6: Return the n-th term
        return res